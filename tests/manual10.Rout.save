
R : Copyright 2001, The R Development Core Team
Version 1.3.1  (2001-08-31)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type `license()' or `licence()' for distribution details.

R is a collaborative project with many contributors.
Type `contributors()' for more information.

Type `demo()' for some demos, `help()' for on-line help, or
`help.start()' for a HTML browser interface to help.
Type `q()' to quit R.

> ###################
> # FROM MANUAL 1.0 #
> ###################
> 
> library(evd)
> options(digits = 4, width = 80)
> set.seed(50)
> 
> # Section: Standard Univariate Functions
> 
> rrweibull(6, loc = 2, scale = .5, shape = c(1, 1.2))
[1] 0.1555 1.8521 1.9409 0.6114 1.6987 1.8714
> qrweibull(seq(0.1, 0.4, 0.1), 2, 0.5, 1, lower.tail = FALSE)
[1] 1.947 1.888 1.822 1.745
> qrweibull(seq(0.9, 0.6, -0.1), loc = 2, scale = 0.5, shape = 1)
[1] 1.947 1.888 1.822 1.745
> prweibull(-1:3, 2, 0.5, 1)
[1] 0.002479 0.018316 0.135335 1.000000 1.000000
> prweibull(-1:3, 2, 0.5, 1, low = FALSE)
[1] 0.9975 0.9817 0.8647 0.0000 0.0000
> drweibull(-1:3, loc = 2, scale = 0.5, shape = 1)
[1] 0.004958 0.036631 0.270671 0.000000 0.000000
> drweibull(-1:3, 2, 0.5, 1, log = TRUE)
[1] -5.307 -3.307 -1.307   -Inf   -Inf
> 
> rext(4, qexp, rate = 1, mlen = 5)
[1] 2.2001 0.8584 4.5595 3.9397
> rext(4, distn = "exp", rate = 1, mlen = 5)
[1] 1.604 1.599 4.053 2.220
> rext(4, distn = "exp", mlen = 5)
[1] 4.906 3.304 3.157 2.291
> rext(1, distn = "norm", mean = 0.5, sd = 2, mlen = 20)
[1] 4.903
> max(rnorm(20, 0.5, 2))
[1] 2.966
> rext(1, distn="norm", sd = 2, mlen = 20, largest = FALSE)
[1] -6.21
> min(rnorm(20, 0, 2))
[1] -3.112
> pext(c(.4, .5), distn="norm", sd = c(1, 2), mlen = 4)
[1] 0.1845 0.1285
> pext(c(.4, .5), distn="norm", mean = 0, sd = c(1, 2), mlen = 4)
[1] 0.1845 0.1285
> dext(c(1, 4), distn="gamma", shape = 1, scale = 0.3, mlen = 100)
[1] 0.3261328 0.0005398
> 
> rorder(1, distn = "norm", mlen = 20, j = 2)
[1] 1.336
> rorder(1, distn = "norm", mlen = 20, j = 19, largest = FALSE)
[1] 1.345
> porder(c(1, 2), distn="gamma", shape =c(.5, .7), mlen = 10, j = 2)
[1] 0.5177 0.8259
> dorder(c(1, 2), distn="gamma", shape =c(.5, .7), mlen = 10, j = 2)
[1] 0.7473 0.3081
> 
> # Section: Standard Bivariate and Multivariate Functions
> 
> rbvalog(3, dep = .8, asy = c(.4, 1))
       [,1]    [,2]
[1,] 1.5248  1.0451
[2,] 0.2877 -0.2457
[3,] 0.7256  1.4770
> rbvalog(3, dep = .8, asy = c(.4, 1), mar1 = c(1, 1, 1))
       [,1]    [,2]
[1,] 4.3391  0.8297
[2,] 0.6297 21.3999
[3,] 4.4126  0.2367
> pbvalog(c(1, 1.2), dep = .4, asy = c(.4, .6), mar1 = c(1, 1, 1))
[1] 0.216
> tmp.quant <- matrix(c(1,1.2,1,2),ncol = 2, byrow = TRUE)
> tmp.mar <- matrix(c(1,1,1,1.2,1.2,1.2), ncol = 3, byrow = TRUE)
> pbvalog(tmp.quant, dep = .4, asy = c(.4, .6), mar1 = tmp.mar)
[1] 0.2160 0.2153
> dbvalog(c(1, 1.2), dep = .4, asy = c(.4, .6), mar1 = c(1, 1, 1))
[1] 0.1427
> dbvalog(tmp.quant, dep = .4, asy = c(.4, .6), mar1 = tmp.mar)
[1] 0.1427 0.0696
> abvalog(dep = .3, asy= c(.7, .9))
[1] 0.7013
> abvalog(seq(0, 1, 0.25), dep = .3, asy = c(.7, .9))
[1] 1.0000 0.8272 0.7013 0.7842 1.0000
> 
> rmvlog(3, dep = .6, d = 5)
        [,1]    [,2]    [,3]    [,4]    [,5]
[1,] 1.74538  0.9195  0.7288  0.5207  0.5722
[2,] 0.00659  0.3480  0.1166 -0.9005 -0.7970
[3,] 0.61353 -0.4328 -0.3287  0.9970 -0.8769
> tmp.mar <- matrix(c(1,1,1,1,1,1.5,1,1,2), ncol = 3, byrow = TRUE)
> rmvlog(3, dep = .6, d = 5, mar = tmp.mar)
       [,1]  [,2]   [,3]   [,4]    [,5]
[1,] 2.0947 2.196 1.3607 1.6064 11.6005
[2,] 0.9536 1.061 1.0652 0.6822  5.5413
[3,] 0.5963 4.937 0.8745 1.2442  0.6395
> tmp.quant <- matrix(rep(c(1,1.5,2), 5), ncol = 5)
> pmvlog(tmp.quant, dep = .6, d = 5, mar = tmp.mar)
[1] 0.07233 0.16387 0.21949
> 
> rmvalog(3, dep = c(.6,.5,.8,.3), asy = list(.4,0,.6,c(.3,.2),c(.1,.1),c(.4,.1),c(.2,.4,.2)), d = 3)
       [,1]   [,2]   [,3]
[1,] 1.0487 4.8371 1.4698
[2,] 0.2002 0.2685 1.4147
[3,] 1.7826 2.1011 0.8223
> pmvalog(c(2, 2, 2), dep = c(.6,.5,.8,.3), asy = list(.4,.0,.6,c(.3,.2),c(.1,.1),c(.4,.1),c(.2,.4,.2)), d = 3)
[1] 0.7223
> tmp.quant <- matrix(rep(c(1,1.5,2), 3), ncol = 3)
> pmvalog(tmp.quant, dep = c(.6,.5,.8,.3), asy = list(.4,.0,.6,c(.3,.2),c(.1,.1),c(.4,.1),c(.2,.4,.2)), d = 3)
[1] 0.4131 0.5849 0.7223
> 
> rmvalog(3, dep = c(rep(1,6),.7,.3,.8,.7,.5), asy = list(0, 0, 0, 0, c(0,0), c(0,0), c(0,0), c(0,0), c(0,0), c(0,0), c(.2,.1,.2), c(.1,.1,.2), c(.3,.4,.1), c(.2,.2,.2), c(.4,.6,.2,.5)), d = 4)
        [,1]  [,2]    [,3]   [,4]
[1,]  0.6258 1.242  2.4371 2.2619
[2,] -0.3428 4.122  2.5950 4.8448
[3,] -0.5947 2.733 -0.3723 0.4123
> 
> rmvalog(3, dep = c(.6,1,.8,.3), asy = list(.4,0,.6,c(.3,.2),c(.0,.0),c(.4,.1),c(.3,.4,.3)), d = 3)
        [,1]    [,2]    [,3]
[1,] -0.9115 -0.1635 -0.4450
[2,]  0.4082  1.4282  0.2809
[3,]  0.1980  0.3856  0.8148
> 
> # Section: Fitting Distributions by Maximum Likelihood
> 
> # Subsection: Univariate Fitting
> 
> data <- rgev(1000, loc = 0.13, scale = 1.1, shape = 0.2)
> fgev(data, start = list(loc = 0, scale = 1, shape = 0), method = "BFGS")
$estimate
   loc  scale  shape 
0.1619 1.1356 0.2018 

$std.err
    loc   scale   shape 
0.04047 0.03207 0.02477 

$deviance
[1] 3641

$counts
function gradient 
      50       13 

> fgev(data, start = list(loc = 0, scale = 1), shape = 0, method = "BFGS")
$estimate
   loc  scale 
0.2967 1.2611 

$std.err
    loc   scale 
0.04160 0.03276 

$deviance
[1] 3741

$counts
function gradient 
      34        9 

> fgev(data, start = list(loc = 0), scale = 1, shape = 0)
$estimate
   loc 
0.1870 

$std.err
    loc 
0.03162 

$deviance
[1] 3831

$counts
function gradient 
      29        5 

> fgev(data, start = list(loc = 0))
$estimate
   loc 
0.1870 

$std.err
    loc 
0.03162 

$deviance
[1] 3831

$counts
function gradient 
      29        5 

> 
> -2*sum(dgev(data, loc = 0.1594, scale = 1.1422, shape = 0.2101, log = TRUE))
[1] 3641
> 
> somedata <- rgev(100,1,1,0.05)
> fgumbel(somedata, start = list(loc = 0.5, scale = 2))
$estimate
  loc scale 
0.944 1.042 

$std.err
    loc   scale 
0.10876 0.08541 

$deviance
[1] 335.7

$counts
function gradient 
      27       10 

> fgev(somedata, start = list(loc = 0.5, scale = 2))
$estimate
  loc scale 
0.944 1.042 

$std.err
    loc   scale 
0.10876 0.08541 

$deviance
[1] 335.7

$counts
function gradient 
      27       10 

> 
> ffrechet(data, start = list(loc=-2,scale=1,shape=5), method ="BFGS")
$estimate
   loc  scale  shape 
-5.465  5.627  4.955 

$std.err
   loc  scale  shape 
0.7000 0.7154 0.6083 

$deviance
[1] 3641

$counts
function gradient 
      40       12 

> data2 <- rgev(1000, loc = 0.13, scale = 1.1, shape = -0.25)
> # CHANGE: starting values
> frweibull(data2, start = list(loc = 5, scale = 5, shape = 10), method="BFGS")
$estimate
  loc scale shape 
4.782 4.739 4.329 

$std.err
   loc  scale  shape 
0.3315 0.3444 0.3580 

$deviance
[1] 3073

$counts
function gradient 
      51       14 

> fgev(data2, start = list(loc=0.13,scale=1.1,shape=0), method="BFGS")
$estimate
     loc    scale    shape 
 0.04329  1.09455 -0.23099 

$std.err
    loc   scale   shape 
0.03806 0.02681 0.01910 

$deviance
[1] 3073

$counts
function gradient 
      56       12 

> 
> data3 <- rext(100, qnorm, mean = 0.56, mlen = 365)
> fext(data3, list(mean = 0, sd = 1), distn = "norm", mlen = 365)
$estimate
  mean     sd 
0.4911 1.0202 

$std.err
   mean      sd 
0.19768 0.07218 

$deviance
[1] 78.15

$counts
function gradient 
      63       NA 

> fext(data3, list(rate = 1), distn = "exp", mlen = 365)
$estimate
 rate 
1.782 

$std.err
   rate 
0.03163 

$deviance
[1] 123.0

$counts
function gradient 
      28       NA 

> fext(data3, list(scale = 1), shape = 0.5, distn = "gamma", mlen = 365)
$estimate
 scale 
0.7334 

$std.err
  scale 
0.01564 

$deviance
[1] 148.7

$counts
function gradient 
      28       NA 

> 
> # Subsection: Bivariate Fitting
> 
> bvdata <- rbvlog(100, dep = 0.6, mar1 = c(1.2,1.4,0.4), mar2 = c(1.2,1.4,0.4))
> fbvlog(bvdata, start = list(mar1 = c(2,1,0), mar2 = c(1,1,0), dep = 0.75), control = list(maxit = 2000))
$estimate
  loc1 scale1 shape1   loc2 scale2 shape2    dep 
1.2018 1.5337 0.5079 1.1626 1.5572 0.5370 0.5892 

$std.err
   loc1  scale1  shape1    loc2  scale2  shape2     dep 
0.17135 0.16848 0.08118 0.17543 0.18040 0.09063 0.05476 

$deviance
[1] 883.4

$counts
function gradient 
      84       28 

> fbvlog(bvdata, start = list(loc1=2, scale1=1, shape1=0, loc2=1, scale2=1, shape2=0, dep=0.75), control = list(maxit = 2000))
$estimate
  loc1 scale1 shape1   loc2 scale2 shape2    dep 
1.2018 1.5337 0.5079 1.1626 1.5572 0.5370 0.5892 

$std.err
   loc1  scale1  shape1    loc2  scale2  shape2     dep 
0.17135 0.16848 0.08118 0.17543 0.18040 0.09063 0.05476 

$deviance
[1] 883.4

$counts
function gradient 
      84       28 

> fbvlog(bvdata, start = list(mar1 = c(2,1,0), mar2 = c(1,1,0), dep = 0.75), method = "BFGS")$counts
function gradient 
      84       28 
> 
> fbvlog(bvdata, start = list(mar1 = c(2,1,0), mar2 = c(1,1,0)), dep = 1, method="BFGS")
$estimate
  loc1 scale1 shape1   loc2 scale2 shape2 
1.2083 1.5348 0.5287 1.1059 1.5432 0.6353 

$std.err
   loc1  scale1  shape1    loc2  scale2  shape2 
0.17257 0.16926 0.09412 0.17336 0.18405 0.10021 

$deviance
[1] 939

$counts
function gradient 
      80       25 

> fgev(bvdata[,1], start = list(loc=1,scale=1,shape=0), method="BFGS")$estimate
   loc  scale  shape 
1.2083 1.5348 0.5287 
> fgev(bvdata[,2], start = list(loc=1,scale=1,shape=0), method="BFGS")$estimate
   loc  scale  shape 
1.1060 1.5433 0.6353 
>  
> fbvlog(bvdata, start = list(loc1=1, scale1=1, loc2=1, scale2=1, dep=0.75), shape1 = 0, shape2 = 0, method = "BFGS")
$estimate
  loc1 scale1   loc2 scale2    dep 
 1.791  2.378  1.744  2.350  0.721 

$std.err
   loc1  scale1    loc2  scale2     dep 
0.24256 0.19138 0.24128 0.18982 0.05682 

$deviance
[1] 1015

$counts
function gradient 
      63       19 

> fbvlog(bvdata, start = list(mar2 = c(1,1,0), dep = 0.75), loc1 = 1, scale1 = 1.5, shape1 = 0.5, method = "BFGS")
$estimate
  loc2 scale2 shape2    dep 
1.0550 1.4828 0.5386 0.5819 

$std.err
   loc2  scale2  shape2     dep 
0.14219 0.13779 0.07396 0.04822 

$deviance
[1] 886.1

$counts
function gradient 
      62       17 

> 
> fbvalog(bvdata, start = list(mar1 = c(1,1,0), mar2 = c(1,1,0), asy = c(.7,.7), dep = 0.75), method = "BFGS")
$estimate
  loc1 scale1 shape1   loc2 scale2 shape2   asy1   asy2    dep 
1.0662 1.4241 0.6180 1.0522 1.5350 0.5854 0.7986 0.9991 0.4934 

$std.err
     loc1    scale1    shape1      loc2    scale2    shape2      asy1      asy2 
1.646e-01 1.475e-01 8.982e-02 1.723e-01 1.877e-01 9.649e-02 1.928e-01 2.000e-06 
      dep 
6.238e-02 

$deviance
[1] 888

$counts
function gradient 
     129       15 

> fbvalog(bvdata, start = list(mar1 = c(0.9,1.2,0.2), mar2 = c(1,1.2,0.3), asy2 = .72, dep = 0.58), asy1 = 1, method = "BFGS")
$estimate
  loc1 scale1 shape1   loc2 scale2 shape2   asy2    dep 
1.0343 1.5444 0.5994 1.0237 1.4636 0.4920 0.9993 0.5696 

$std.err
     loc1    scale1    shape1      loc2    scale2    shape2      asy2       dep 
1.687e-01 1.886e-01 1.088e-01 1.601e-01 1.649e-01 7.956e-02 2.000e-06 5.522e-02 

$deviance
[1] 889.4

$counts
function gradient 
     112       11 

> # CHANGE: std.err = FALSE
> fbvalog(bvdata, start = list(mar1 = c(0.9,1.2,0.2), mar2 = c(1,1.2,0.3), asy = c(.99,.72), dep = 0.58), method = "L-BFGS-B", lower = c(rep(-Inf, 6), 0, 0, -Inf), upper = c(rep(Inf, 6), 1, 1, 1), std.err = FALSE)
$estimate
  loc1 scale1 shape1   loc2 scale2 shape2   asy1   asy2    dep 
1.2018 1.5337 0.5079 1.1626 1.5572 0.5370 1.0000 1.0000 0.5893 

$std.err
  loc1 scale1 shape1   loc2 scale2 shape2   asy1   asy2    dep 
    NA     NA     NA     NA     NA     NA     NA     NA     NA 

$deviance
[1] 883.4

$counts
function gradient 
      24       24 

> fbvalog(bvdata, start = list(mar1 = c(1.5,1.4,0.1), mar2 = c(1.4,1.4,0.2), 
+ dep = 0.73), asy1 = 1, asy2 = 1, method="BFGS")
$estimate
  loc1 scale1 shape1   loc2 scale2 shape2    dep 
1.2025 1.5345 0.5080 1.1634 1.5581 0.5371 0.5891 

$std.err
   loc1  scale1  shape1    loc2  scale2  shape2     dep 
0.17144 0.16865 0.08121 0.17555 0.18059 0.09067 0.05476 

$deviance
[1] 883.4

$counts
function gradient 
      63       18 

> 
> # Subsection: A Univariate Example
> 
> data(oxford)
> sqrt(6 * var(oxford))/pi
[1] 3.326
> mean(oxford) - 0.58 * sqrt(6 * var(oxford))/pi
[1] 83.4
> oxford.fit <- fgev(oxford, start = list(loc=83.5, scale=3.5, shape=0))
> oxford.fit
$estimate
    loc   scale   shape 
83.8385  4.2600 -0.2873 

$std.err
    loc   scale   shape 
0.52313 0.36586 0.06832 

$deviance
[1] 457.8

$counts
function gradient 
      42       14 

> fgev(oxford, start = list(loc=83.8, scale=4.25))$deviance - oxford.fit$deviance
[1] 12
> 
> mle <- oxford.fit$estimate
> as.vector(mle[1] - mle[2]/mle[3])
[1] 98.67
> range(oxford)
[1] 75 95
> 
> fext(oxford, start = list(mean = 40, sd = 1), distn = "norm", mlen = 365)
$estimate
 mean    sd 
48.85 12.43 

$std.err
  mean     sd 
2.7204 0.9928 

$deviance
[1] 464.2

$counts
function gradient 
      51       NA 

> fext(oxford, start = list(scale = 1, shape = 1), distn = "gamma", mlen = 365)
$estimate
scale shape 
 1.63 32.94 

$std.err
 scale  shape 
0.2407 6.0378 

$deviance
[1] 465.9

$counts
function gradient 
     353       NA 

> 
> # Subsection: A Bivariate Example
> 
> data(sealevel)
> sl <- sealevel
> # CHANGE: na.rm = TRUE
> sqrt(6 * c(var(sl[,1], na.rm = TRUE), var(sl[,2], na.rm = TRUE)))/pi
[1] 0.1995 0.2467
> c(mean(sl[,1], na.rm = TRUE), mean(sl[,2], na.rm = TRUE)) - 0.58 * c(0.21, 0.24)
[1] 3.583 2.551
> 
> tmp <- fbvlog(sl, start = list(mar1 = c(3.6, 0.2, 0), mar2 = c(2.6, 0.25, 0)), dep = 1, method = "BFGS")
> tmp <- fbvalog(sl, start = list(mar1 = c(3.6, 0.2, 0), mar2 = c(2.6, 0.25, 0)), asy1 = 1, asy2 = 1, dep = 1, method = "BFGS")
> # CHANGE: dependence parameter fixed at lower limit
> tmp <- fbvhr(sl, start = list(mar1 = c(3.6, 0.2, 0), mar2 = c(2.6, 0.25, 0)), dep = 0.2, method = "BFGS")
> tmp$estimate
     loc1    scale1    shape1      loc2    scale2    shape2 
 3.592515  0.201954 -0.021077  2.553020  0.241505 -0.002815 
> 
> sl.fit <- fbvalog(sl, start = list(mar1 = c(3.6, 0.2, 0), mar2 = c(2.6, 0.25, 0), asy = c(0.8, 0.8), dep = 0.6), method = "BFGS", control = list(trace=1))
initial  value -3.152236 
iter  10 value -5.656805
iter  20 value -6.603483
final  value -6.603500 
converged
> sl.fit
$estimate
    loc1   scale1   shape1     loc2   scale2   shape2     asy1     asy2 
 3.59306  0.20927 -0.10774  2.55778  0.23728 -0.01642  0.53787  0.43006 
     dep 
 0.19248 

$std.err
   loc1  scale1  shape1    loc2  scale2  shape2    asy1    asy2     dep 
0.02750 0.02021 0.07093 0.03540 0.02277 0.06987 0.20954 0.14316 0.11141 

$deviance
[1] -13.21

$counts
function gradient 
     146       25 

> 
> fbvalog(sl, start = list(loc1 = 3.6, scale1 = 0.19, loc2 = 2.6, scale2 = 0.2, asy = c(0.7, 0.45), dep = 0.24), method = "BFGS")$deviance - sl.fit$deviance
[1] 2.930
> tmp$deviance - sl.fit$deviance
[1] 23.32
> 
> # CHANGE: na.rm = TRUE
> mle <- sl.fit$estimate
> as.vector(mle[1] - mle[2]/mle[3])
[1] 5.535
> range(sl[,1], na.rm = TRUE)
[1] 3.24 4.57
> as.vector(mle[4] - mle[5]/mle[6])
[1] 17.01
> range(sl[,2], na.rm = TRUE)
[1] 2.16 3.99
> 
> sl.fit2 <- fbvalog(sl, start = list(mar1 = c(3.6, 0.19, -0.04), mar2 = c(2.6, 0.2, 0.09), dep = 0.6), asy1 = 1, asy2 = 1, method = "BFGS")
> sl.fit2 <- fbvlog(sl, start = list(mar1 = c(3.6, 0.19, -0.04), mar2 = c(2.6, 0.2, 0.09), dep = 0.6), method = "BFGS")
> sl.fit2$estimate
    loc1   scale1   shape1     loc2   scale2   shape2      dep 
 3.58745  0.20464 -0.07656  2.55383  0.23865 -0.02558  0.63220 
> sl.fit2$deviance
[1] -9.676
> sl.fit2$deviance - sl.fit$deviance
[1] 3.531
> abvalog(dep = 0.24316, asy = c(0.69554, 0.44967))
[1] 0.7884
> abvlog(dep = 0.62474)
[1] 0.771
> 
> fbvhr(sl, start = list(mar1 = c(3.6, 0.19, -0.04), mar2 = c(2.6, 0.2, 0.09),  dep = 1), method = "BFGS", control = list(trace=1))
initial  value 5.767495 
iter  10 value -3.909563
final  value -4.032986 
converged
$estimate
    loc1   scale1   shape1     loc2   scale2   shape2      dep 
 3.58772  0.20354 -0.06868  2.55535  0.23994 -0.03556  1.22719 

$std.err
   loc1  scale1  shape1    loc2  scale2  shape2     dep 
0.02662 0.01982 0.07516 0.03504 0.02554 0.06423 0.24525 

$deviance
[1] -8.066

$counts
function gradient 
      50       15 

> abvhr(dep = 1.253410)
[1] 0.7875
> fbvaneglog(sl, start = list(mar1 = c(3.6, 0.19, -0.04), mar2 = c(2.6, 0.2, 0.09), dep = 1, asy = c(0.8,0.8)), method = "BFGS", control = list(trace=1))
initial  value 4.330513 
iter  10 value -4.628613
iter  20 value -6.580824
iter  30 value -6.595496
final  value -6.595509 
converged
$estimate
    loc1   scale1   shape1     loc2   scale2   shape2      dep     asy1 
 3.59354  0.20949 -0.10916  2.55795  0.23731 -0.01787  4.75133  0.52649 
    asy2 
 0.42333 

$std.err
   loc1  scale1  shape1    loc2  scale2  shape2     dep    asy1    asy2 
0.02737 0.02008 0.06997 0.03541 0.02267 0.06926 2.84161 0.19780 0.13457 

$deviance
[1] -13.19

$counts
function gradient 
     158       34 

> abvaneglog(dep = 3.44762, asy = c(0.69796,0.44601))
[1] 0.7892
> fbvaneglog(sl, start = list(mar1 = c(3.6, 0.19, -0.04), mar2 = c(2.6, 0.2, 0.09), dep = 1), asy1 = 1, asy2 = 1, method = "BFGS", control = list(trace=1))
initial  value 5.805994 
iter  10 value -4.219442
final  value -4.424986 
converged
$estimate
    loc1   scale1   shape1     loc2   scale2   shape2      dep 
 3.58717  0.20427 -0.07082  2.55491  0.23975 -0.02923  0.84695 

$std.err
   loc1  scale1  shape1    loc2  scale2  shape2     dep 
0.02665 0.02003 0.07524 0.03482 0.02537 0.06445 0.22916 

$deviance
[1] -8.85

$counts
function gradient 
      48       16 

> abvneglog(dep = 0.87394)
[1] 0.7738
> 
> fbvalog(sl, start = list(mar1 = c(3.63, 0.18, -0.04), mar2 = c(2.63, 0.2, 0.09), dep = 0.24), asy1 = 0.4492, asy2 = 0.4492, method = "BFGS")
$estimate
    loc1   scale1   shape1     loc2   scale2   shape2      dep 
 3.60242  0.21252 -0.11870  2.54454  0.23260 -0.01961  0.17807 

$std.err
   loc1  scale1  shape1    loc2  scale2  shape2     dep 
0.02509 0.01970 0.06695 0.03116 0.02189 0.06696 0.07781 

$deviance
[1] -12.53

$counts
function gradient 
     124       26 

> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
